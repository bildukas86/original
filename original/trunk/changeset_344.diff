Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/instancemanager/DuelManager.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/instancemanager/DuelManager.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/instancemanager/DuelManager.java	(revision 344)
@@ -15,7 +15,7 @@
 package net.sf.l2j.gameserver.instancemanager;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Logger;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import net.sf.l2j.gameserver.model.L2Effect;
@@ -24,7 +24,8 @@
 import net.sf.l2j.gameserver.network.serverpackets.L2GameServerPacket;
 
-public class DuelManager
+public final class DuelManager
 {
-	private static final Logger _log = Logger.getLogger(DuelManager.class.getName());
+	private final Map<Integer, Duel> _duels = new ConcurrentHashMap<>();
+	private final AtomicInteger _currentDuelId = new AtomicInteger();
 	
 	public static final DuelManager getInstance()
@@ -33,30 +34,12 @@
 	}
 	
-	private final List<Duel> _duels;
-	private int _currentDuelId = 0x90;
-	
 	protected DuelManager()
 	{
-		_log.info("Initializing DuelManager");
-		_duels = new ArrayList<>();
-	}
-	
-	private int getNextDuelId()
-	{
-		// In case someone wants to run the server forever :)
-		if (++_currentDuelId >= 2147483640)
-			_currentDuelId = 1;
 		
-		return _currentDuelId;
 	}
 	
 	public Duel getDuel(int duelId)
 	{
-		for (Duel duel : _duels)
-		{
-			if (duel.getId() == duelId)
-				return duel;
-		}
-		return null;
+		return _duels.get(duelId);
 	}
 	
@@ -66,54 +49,6 @@
 			return;
 		
-		// return if a player has PvPFlag
-		String engagedInPvP = "The duel was canceled because a duelist engaged in PvP combat.";
-		if (partyDuel == 1)
-		{
-			boolean playerInPvP = false;
-			for (L2PcInstance temp : playerA.getParty().getPartyMembers())
-			{
-				if (temp.getPvpFlag() != 0)
-				{
-					playerInPvP = true;
-					break;
-				}
-			}
-			
-			if (!playerInPvP)
-			{
-				for (L2PcInstance temp : playerB.getParty().getPartyMembers())
-				{
-					if (temp.getPvpFlag() != 0)
-					{
-						playerInPvP = true;
-						break;
-					}
-				}
-			}
-			
-			// A player has PvP flag
-			if (playerInPvP)
-			{
-				for (L2PcInstance temp : playerA.getParty().getPartyMembers())
-					temp.sendMessage(engagedInPvP);
-				
-				for (L2PcInstance temp : playerB.getParty().getPartyMembers())
-					temp.sendMessage(engagedInPvP);
-				
-				return;
-			}
-		}
-		else
-		{
-			if (playerA.getPvpFlag() != 0 || playerB.getPvpFlag() != 0)
-			{
-				playerA.sendMessage(engagedInPvP);
-				playerB.sendMessage(engagedInPvP);
-				return;
-			}
-		}
-		
-		Duel duel = new Duel(playerA, playerB, partyDuel, getNextDuelId());
-		_duels.add(duel);
+		final int duelId = _currentDuelId.incrementAndGet();
+		_duels.put(duelId, new Duel(playerA, playerB, partyDuel, duelId));
 	}
 	
@@ -128,11 +63,12 @@
 			return;
 		
-		Duel duel = getDuel(player.getDuelId());
-		duel.doSurrender(player);
+		final Duel duel = getDuel(player.getDuelId());
+		if (duel != null)
+			duel.doSurrender(player);
 	}
 	
 	/**
 	 * Updates player states.
-	 * @param player - the dieing player
+	 * @param player - the dying player
 	 */
 	public void onPlayerDefeat(L2PcInstance player)
@@ -141,5 +77,5 @@
 			return;
 		
-		Duel duel = getDuel(player.getDuelId());
+		final Duel duel = getDuel(player.getDuelId());
 		if (duel != null)
 			duel.onPlayerDefeat(player);
@@ -156,5 +92,5 @@
 			return;
 		
-		Duel duel = getDuel(player.getDuelId());
+		final Duel duel = getDuel(player.getDuelId());
 		if (duel != null)
 			duel.onBuff(player, buff);
@@ -170,5 +106,5 @@
 			return;
 		
-		Duel duel = getDuel(player.getDuelId());
+		final Duel duel = getDuel(player.getDuelId());
 		if (duel != null)
 			duel.onRemoveFromParty(player);
@@ -185,9 +121,6 @@
 			return;
 		
-		Duel duel = getDuel(player.getDuelId());
+		final Duel duel = getDuel(player.getDuelId());
 		if (duel == null)
-			return;
-		
-		if (duel.getPlayerA() == null || duel.getPlayerB() == null)
 			return;
 		
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/itemcontainer/PcInventory.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/itemcontainer/PcInventory.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/itemcontainer/PcInventory.java	(revision 344)
@@ -665,9 +665,9 @@
 		return validateCapacity(slots);
 	}
-		
+	
 	public boolean validateCapacityByItemId(int ItemId)
 	{
 		int slots = 0;
-			
+		
 		ItemInstance invItem = getItemByItemId(ItemId);
 		if (!(invItem != null && invItem.isStackable()))
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/SummonStatus.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/SummonStatus.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/SummonStatus.java	(revision 344)
@@ -18,5 +18,5 @@
 import net.sf.l2j.gameserver.model.actor.L2Summon;
 import net.sf.l2j.gameserver.model.actor.instance.L2PcInstance;
-import net.sf.l2j.gameserver.model.entity.Duel;
+import net.sf.l2j.gameserver.model.entity.Duel.DuelState;
 
 public class SummonStatus extends PlayableStatus
@@ -43,5 +43,5 @@
 			final L2PcInstance attackerPlayer = attacker.getActingPlayer();
 			if (attackerPlayer != null && (getActiveChar().getOwner() == null || getActiveChar().getOwner().getDuelId() != attackerPlayer.getDuelId()))
-				attackerPlayer.setDuelState(Duel.DUELSTATE_INTERRUPTED);
+				attackerPlayer.setDuelState(DuelState.INTERRUPTED);
 		}
 		super.reduceHp(value, attacker, awake, isDOT, isHPConsumption);
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/NpcStatus.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/NpcStatus.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/NpcStatus.java	(revision 344)
@@ -18,5 +18,5 @@
 import net.sf.l2j.gameserver.model.actor.L2Npc;
 import net.sf.l2j.gameserver.model.actor.instance.L2PcInstance;
-import net.sf.l2j.gameserver.model.entity.Duel;
+import net.sf.l2j.gameserver.model.entity.Duel.DuelState;
 
 public class NpcStatus extends CharStatus
@@ -43,5 +43,5 @@
 			final L2PcInstance attackerPlayer = attacker.getActingPlayer();
 			if (attackerPlayer != null && attackerPlayer.isInDuel())
-				attackerPlayer.setDuelState(Duel.DUELSTATE_INTERRUPTED);
+				attackerPlayer.setDuelState(DuelState.INTERRUPTED);
 			
 			// Add attackers to npc's attacker list
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/PcStatus.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/PcStatus.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/status/PcStatus.java	(revision 344)
@@ -24,5 +24,5 @@
 import net.sf.l2j.gameserver.model.actor.instance.L2SummonInstance;
 import net.sf.l2j.gameserver.model.actor.stat.PcStat;
-import net.sf.l2j.gameserver.model.entity.Duel;
+import net.sf.l2j.gameserver.model.entity.Duel.DuelState;
 import net.sf.l2j.gameserver.model.quest.QuestState;
 import net.sf.l2j.gameserver.network.SystemMessageId;
@@ -106,13 +106,13 @@
 				if (getActiveChar().isInDuel())
 				{
-					if (getActiveChar().getDuelState() == Duel.DUELSTATE_DEAD)
+					if (getActiveChar().getDuelState() == DuelState.DEAD)
 						return;
 					
-					if (getActiveChar().getDuelState() == Duel.DUELSTATE_WINNER)
+					if (getActiveChar().getDuelState() == DuelState.WINNER)
 						return;
 					
 					// cancel duel if player got hit by another player, that is not part of the duel
 					if (attackerPlayer.getDuelId() != getActiveChar().getDuelId())
-						getActiveChar().setDuelState(Duel.DUELSTATE_INTERRUPTED);
+						getActiveChar().setDuelState(DuelState.INTERRUPTED);
 				}
 			}
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/L2PcInstance.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/L2PcInstance.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/L2PcInstance.java	(revision 344)
@@ -123,5 +123,5 @@
 import net.sf.l2j.gameserver.model.base.SubClass;
 import net.sf.l2j.gameserver.model.entity.Castle;
-import net.sf.l2j.gameserver.model.entity.Duel;
+import net.sf.l2j.gameserver.model.entity.Duel.DuelState;
 import net.sf.l2j.gameserver.model.entity.Hero;
 import net.sf.l2j.gameserver.model.entity.Siege;
@@ -434,5 +434,5 @@
 	
 	private boolean _isInDuel = false;
-	private int _duelState = Duel.DUELSTATE_NODUEL;
+	private DuelState _duelState = DuelState.NO_DUEL;
 	private int _duelId = 0;
 	private SystemMessageId _noDuelReason = SystemMessageId.THERE_IS_NO_OPPONENT_TO_RECEIVE_YOUR_CHALLENGE_FOR_A_DUEL;
@@ -6611,5 +6611,5 @@
 			
 			// is AutoAttackable if both players are in the same duel and the duel is still going on
-			if (getDuelState() == Duel.DUELSTATE_DUELLING && getDuelId() == cha.getDuelId())
+			if (getDuelState() == DuelState.DUELLING && getDuelId() == cha.getDuelId())
 				return true;
 			
@@ -7998,10 +7998,10 @@
 	}
 	
-	public void setDuelState(int mode)
-	{
-		_duelState = mode;
-	}
-	
-	public int getDuelState()
+	public void setDuelState(DuelState state)
+	{
+		_duelState = state;
+	}
+	
+	public DuelState getDuelState()
 	{
 		return _duelState;
@@ -8012,15 +8012,15 @@
 	 * @param duelId 0=not in a duel
 	 */
-	public void setIsInDuel(int duelId)
+	public void setInDuel(int duelId)
 	{
 		if (duelId > 0)
 		{
 			_isInDuel = true;
-			_duelState = Duel.DUELSTATE_DUELLING;
+			_duelState = DuelState.DUELLING;
 			_duelId = duelId;
 		}
 		else
 		{
-			if (_duelState == Duel.DUELSTATE_DEAD)
+			if (_duelState == DuelState.DEAD)
 			{
 				enableAllSkills();
@@ -8028,5 +8028,5 @@
 			}
 			_isInDuel = false;
-			_duelState = Duel.DUELSTATE_NODUEL;
+			_duelState = DuelState.NO_DUEL;
 			_duelId = 0;
 		}
@@ -8059,5 +8059,5 @@
 		else if (isInOlympiadMode())
 			_noDuelReason = SystemMessageId.S1_CANNOT_DUEL_BECAUSE_S1_IS_PARTICIPATING_IN_THE_OLYMPIAD;
-		else if (isCursedWeaponEquipped())
+		else if (isCursedWeaponEquipped() || getKarma() != 0)
 			_noDuelReason = SystemMessageId.S1_CANNOT_DUEL_BECAUSE_S1_IS_IN_A_CHAOTIC_STATE;
 		else if (isInStoreMode())
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Duel.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Duel.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Duel.java	(revision 344)
@@ -15,9 +15,8 @@
 package net.sf.l2j.gameserver.model.entity;
 
-import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
 
 import net.sf.l2j.gameserver.ThreadPoolManager;
@@ -40,32 +39,38 @@
 public class Duel
 {
-	protected static final Logger _log = Logger.getLogger(Duel.class.getName());
-	
-	public static final int DUELSTATE_NODUEL = 0;
-	public static final int DUELSTATE_DUELLING = 1;
-	public static final int DUELSTATE_DEAD = 2;
-	public static final int DUELSTATE_WINNER = 3;
-	public static final int DUELSTATE_INTERRUPTED = 4;
+	public static enum DuelState
+	{
+		NO_DUEL,
+		DUELLING,
+		DEAD,
+		WINNER,
+		INTERRUPTED
+	}
+	
+	private static final PlaySound B04_S01 = new PlaySound(1, "B04_S01", 0, 0, 0, 0, 0);
+	
+	private static enum DuelResult
+	{
+		CONTINUE,
+		TEAM_1_WIN,
+		TEAM_2_WIN,
+		TEAM_1_SURRENDER,
+		TEAM_2_SURRENDER,
+		CANCELED,
+		TIMEOUT
+	}
 	
 	private final int _duelId;
-	private L2PcInstance _playerA, _playerB;
 	private final boolean _partyDuel;
 	private final Calendar _duelEndTime;
-	private int _surrenderRequest = 0;
-	private int _countdown = 4;
-	private boolean _finished = false;
-	
-	private List<PlayerCondition> _playerConditions;
-	
-	public static enum DuelResultEnum
-	{
-		Continue,
-		Team1Win,
-		Team2Win,
-		Team1Surrender,
-		Team2Surrender,
-		Canceled,
-		Timeout
-	}
+	private final L2PcInstance _playerA;
+	private final L2PcInstance _playerB;
+	private final List<PlayerCondition> _playerConditions = new CopyOnWriteArrayList<>();
+	
+	private int _surrenderRequest;
+	
+	protected Future<?> _startTask = null;
+	protected Future<?> _checkTask = null;
+	protected int _countdown = 5;
 	
 	public Duel(L2PcInstance playerA, L2PcInstance playerB, int partyDuel, int duelId)
@@ -74,37 +79,43 @@
 		_playerA = playerA;
 		_playerB = playerB;
-		_partyDuel = partyDuel == 1 ? true : false;
+		_partyDuel = (partyDuel == 1) ? true : false;
 		
 		_duelEndTime = Calendar.getInstance();
+		_duelEndTime.add(Calendar.SECOND, 120);
+		
 		if (_partyDuel)
-			_duelEndTime.add(Calendar.SECOND, 300);
-		else
-			_duelEndTime.add(Calendar.SECOND, 120);
-		
-		_playerConditions = new ArrayList<>();
-		
-		setFinished(false);
-		
-		if (_partyDuel)
-		{
-			// increase countdown so that start task can teleport players
-			_countdown++;
-			// inform players that they will be portet shortly
+		{
+			_countdown = 35;
+			
+			// Inform players that they will be ported shortly.
 			SystemMessage sm = SystemMessage.getSystemMessage(SystemMessageId.IN_A_MOMENT_YOU_WILL_BE_TRANSPORTED_TO_THE_SITE_WHERE_THE_DUEL_WILL_TAKE_PLACE);
 			broadcastToTeam1(sm);
 			broadcastToTeam2(sm);
 		}
-		// Schedule duel start
-		ThreadPoolManager.getInstance().scheduleGeneral(new ScheduleStartDuelTask(this), 3000);
-	}
-	
-	public static class PlayerCondition
+		
+		savePlayerConditions();
+		
+		// Start task, used for countdowns and startDuel method call. Can be shutdowned if the check task commands it.
+		_startTask = ThreadPoolManager.getInstance().scheduleGeneralAtFixedRate(new StartTask(), 1000, 1000);
+		
+		// Check task, used to verify if duel is disturbed.
+		_checkTask = ThreadPoolManager.getInstance().scheduleGeneralAtFixedRate(new CheckTask(), 1000, 1000);
+	}
+	
+	/**
+	 * This class hold important player informations, which will be restored on duel end.
+	 */
+	private static class PlayerCondition
 	{
 		private L2PcInstance _player;
+		
 		private double _hp;
 		private double _mp;
 		private double _cp;
-		private boolean _paDuel;
-		private int _x, _y, _z;
+		
+		private int _x;
+		private int _y;
+		private int _z;
+		
 		private List<L2Effect> _debuffs;
 		
@@ -118,7 +129,6 @@
 			_mp = _player.getCurrentMp();
 			_cp = _player.getCurrentCp();
-			_paDuel = partyDuel;
-			
-			if (_paDuel)
+			
+			if (partyDuel)
 			{
 				_x = _player.getX();
@@ -128,7 +138,9 @@
 		}
 		
-		public void restoreCondition()
-		{
-			if (_player == null)
+		public void restoreCondition(boolean abnormalEnd)
+		{
+			teleportBack();
+			
+			if (abnormalEnd)
 				return;
 			
@@ -137,12 +149,9 @@
 			_player.setCurrentCp(_cp);
 			
-			if (_paDuel)
-				teleportBack();
-			
-			if (_debuffs != null) // Debuff removal
-			{
-				for (L2Effect temp : _debuffs)
-					if (temp != null)
-						temp.exit();
+			if (_debuffs != null)
+			{
+				for (L2Effect skill : _debuffs)
+					if (skill != null)
+						skill.exit();
 			}
 		}
@@ -151,5 +160,5 @@
 		{
 			if (_debuffs == null)
-				_debuffs = new ArrayList<>();
+				_debuffs = new CopyOnWriteArrayList<>();
 			
 			_debuffs.add(debuff);
@@ -158,5 +167,5 @@
 		public void teleportBack()
 		{
-			if (_paDuel)
+			if (_x != 0 && _y != 0)
 				_player.teleToLocation(_x, _y, _z, 0);
 		}
@@ -168,11 +177,17 @@
 	}
 	
-	public class ScheduleDuelTask implements Runnable
-	{
-		private final Duel _duel;
-		
-		public ScheduleDuelTask(Duel duel)
-		{
-			_duel = duel;
+	/**
+	 * This task makes the countdown, both for party and 1vs1 cases.
+	 * <ul>
+	 * <li>For 1vs1, the timer begins to 5 (messages then start duel process).</li>
+	 * <li>For party duel, the timer begins to 35 (2sec break, teleport parties, 3sec break, messages then start duel process).</li>
+	 * </ul>
+	 * The task is running until countdown reaches -1 (0 being startDuel).
+	 */
+	private class StartTask implements Runnable
+	{
+		public StartTask()
+		{
+			
 		}
 		
@@ -180,37 +195,57 @@
 		public void run()
 		{
-			try
-			{
-				DuelResultEnum status = _duel.checkEndDuelCondition();
-				
-				if (status == DuelResultEnum.Canceled)
-				{
-					// do not schedule duel end if it was interrupted
-					setFinished(true);
-					_duel.endDuel(status);
-				}
-				else if (status != DuelResultEnum.Continue)
-				{
-					setFinished(true);
-					playKneelAnimation();
-					ThreadPoolManager.getInstance().scheduleGeneral(new ScheduleEndDuelTask(_duel, status), 5000);
-				}
-				else
-					ThreadPoolManager.getInstance().scheduleGeneral(this, 1000);
-			}
-			catch (Exception e)
-			{
-				_log.log(Level.SEVERE, "", e);
-			}
-		}
-	}
-	
-	public static class ScheduleStartDuelTask implements Runnable
-	{
-		private final Duel _duel;
-		
-		public ScheduleStartDuelTask(Duel duel)
-		{
-			_duel = duel;
+			// Schedule anew, until time reaches 0.
+			if (_countdown < 0)
+			{
+				_startTask.cancel(true);
+				_startTask = null;
+			}
+			
+			switch (_countdown)
+			{
+				case 33:
+					teleportPlayers(-83760, -238825, -3331);
+					break;
+				
+				case 30:
+				case 20:
+				case 15:
+				case 10:
+				case 5:
+				case 4:
+				case 3:
+				case 2:
+				case 1:
+					SystemMessage sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_WILL_BEGIN_IN_S1_SECONDS).addNumber(_countdown);
+					broadcastToTeam1(sm);
+					broadcastToTeam2(sm);
+					break;
+				
+				case 0:
+					sm = SystemMessage.getSystemMessage(SystemMessageId.LET_THE_DUEL_BEGIN);
+					broadcastToTeam1(sm);
+					broadcastToTeam2(sm);
+					
+					startDuel();
+					break;
+			}
+			
+			// Decrease timer.
+			_countdown--;
+		}
+	}
+	
+	/**
+	 * This task listens the different ways to disturb the duel. Two cases are possible :
+	 * <ul>
+	 * <li>DuelResult is under CONTINUE state, nothing happens. The task will continue to run every second.</li>
+	 * <li>DuelResult is anything except CONTINUE, then the duel ends. Animations are played on any duel end cases, except CANCELED.</li>
+	 * </ul>
+	 */
+	private class CheckTask implements Runnable
+	{
+		public CheckTask()
+		{
+			
 		}
 		
@@ -218,54 +253,28 @@
 		public void run()
 		{
-			try
-			{
-				// start/continue countdown
-				int count = _duel.countdown();
-				
-				if (count == 4)
+			final DuelResult status = checkEndDuelCondition();
+			
+			if (status != DuelResult.CONTINUE)
+			{
+				// Abort the start task if it was currently running. Interrupt it, even if it was on a loop.
+				if (_startTask != null)
 				{
-					// players need to be teleportet first
-					// TODO: stadia manager needs a function to return an unused stadium for duels
-					// currently only teleports to the same stadium
-					_duel.teleportPlayers(-83760, -238825, -3331);
-					
-					// give players 20 seconds to complete teleport and get ready (its ought to be 30 on offical..)
-					ThreadPoolManager.getInstance().scheduleGeneral(this, 20000);
+					_startTask.cancel(true);
+					_startTask = null;
 				}
-				else if (count > 0) // duel not started yet - continue countdown
+				
+				// Abort the check task. Let this last loop alive.
+				if (_checkTask != null)
 				{
-					ThreadPoolManager.getInstance().scheduleGeneral(this, 1000);
+					_checkTask.cancel(false);
+					_checkTask = null;
 				}
-				else
-					_duel.startDuel();
-			}
-			catch (Exception e)
-			{
-				_log.log(Level.SEVERE, "", e);
-			}
-		}
-	}
-	
-	public static class ScheduleEndDuelTask implements Runnable
-	{
-		private final Duel _duel;
-		private final DuelResultEnum _result;
-		
-		public ScheduleEndDuelTask(Duel duel, DuelResultEnum result)
-		{
-			_duel = duel;
-			_result = result;
-		}
-		
-		@Override
-		public void run()
-		{
-			try
-			{
-				_duel.endDuel(_result);
-			}
-			catch (Exception e)
-			{
-				_log.log(Level.SEVERE, "", e);
+				
+				stopFighting();
+				
+				if (status != DuelResult.CANCELED)
+					playAnimations();
+				
+				endDuel(status);
 			}
 		}
@@ -275,22 +284,22 @@
 	 * Stops all players from attacking. Used for duel timeout / interrupt.
 	 */
-	private void stopFighting()
-	{
-		ActionFailed af = ActionFailed.STATIC_PACKET;
+	protected void stopFighting()
+	{
 		if (_partyDuel)
 		{
-			for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-			{
-				temp.abortCast();
-				temp.getAI().setIntention(CtrlIntention.ACTIVE);
-				temp.setTarget(null);
-				temp.sendPacket(af);
-			}
-			for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-			{
-				temp.abortCast();
-				temp.getAI().setIntention(CtrlIntention.ACTIVE);
-				temp.setTarget(null);
-				temp.sendPacket(af);
+			for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+			{
+				partyPlayer.abortCast();
+				partyPlayer.getAI().setIntention(CtrlIntention.ACTIVE);
+				partyPlayer.setTarget(null);
+				partyPlayer.sendPacket(ActionFailed.STATIC_PACKET);
+			}
+			
+			for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+			{
+				partyPlayer.abortCast();
+				partyPlayer.getAI().setIntention(CtrlIntention.ACTIVE);
+				partyPlayer.setTarget(null);
+				partyPlayer.sendPacket(ActionFailed.STATIC_PACKET);
 			}
 		}
@@ -303,73 +312,39 @@
 			_playerB.getAI().setIntention(CtrlIntention.ACTIVE);
 			_playerB.setTarget(null);
-			_playerA.sendPacket(af);
-			_playerB.sendPacket(af);
-		}
-	}
-	
-	/**
-	 * Check if a player engaged in pvp combat (only for 1on1 duels)
-	 * @param sendMessage true will return a message for both duelists.
-	 * @return returns true if a duelist is engaged in Pvp combat
-	 */
-	public boolean isDuelistInPvp(boolean sendMessage)
-	{
-		// Party duels take place in arenas - should be no other players there
+			_playerA.sendPacket(ActionFailed.STATIC_PACKET);
+			_playerB.sendPacket(ActionFailed.STATIC_PACKET);
+		}
+	}
+	
+	/**
+	 * Starts the duel.<br>
+	 * Save players conditions, cancel active trade, set the team color and all duel start packets.<br>
+	 * Handle the duel task, which checks if the duel ends in one way or another.
+	 */
+	protected void startDuel()
+	{
 		if (_partyDuel)
-			return false;
-		
-		if (_playerA.getPvpFlag() != 0 || _playerB.getPvpFlag() != 0)
-		{
-			if (sendMessage)
-			{
-				String engagedInPvP = "The duel was canceled because a duelist engaged in PvP combat.";
-				_playerA.sendMessage(engagedInPvP);
-				_playerB.sendMessage(engagedInPvP);
-			}
-			return true;
-		}
-		return false;
-	}
-	
-	/**
-	 * Starts the duel
-	 */
-	public void startDuel()
-	{
-		// Save player Conditions
-		savePlayerConditions();
-		
-		if (_playerA == null || _playerB == null || _playerA.isInDuel() || _playerB.isInDuel())
-		{
-			// clean up
-			_playerConditions.clear();
-			_playerConditions = null;
-			DuelManager.getInstance().removeDuel(this);
-			return;
-		}
-		
-		if (_partyDuel)
-		{
-			// set isInDuel() state
-			// cancel all active trades, just in case? xD
-			for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-			{
-				temp.cancelActiveTrade();
-				temp.setIsInDuel(_duelId);
-				temp.setTeam(1);
-				temp.broadcastUserInfo();
-				broadcastToTeam2(new ExDuelUpdateUserInfo(temp));
-			}
-			
-			for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-			{
-				temp.cancelActiveTrade();
-				temp.setIsInDuel(_duelId);
-				temp.setTeam(2);
-				temp.broadcastUserInfo();
-				broadcastToTeam1(new ExDuelUpdateUserInfo(temp));
-			}
-			
-			// Send duel Start packets
+		{
+			for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+			{
+				partyPlayer.cancelActiveTrade();
+				partyPlayer.setInDuel(_duelId);
+				partyPlayer.setTeam(1);
+				partyPlayer.broadcastUserInfo();
+				// TODO Servitors getTeam update
+				broadcastToTeam2(new ExDuelUpdateUserInfo(partyPlayer));
+			}
+			
+			for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+			{
+				partyPlayer.cancelActiveTrade();
+				partyPlayer.setInDuel(_duelId);
+				partyPlayer.setTeam(2);
+				partyPlayer.broadcastUserInfo();
+				// TODO Servitors getTeam update
+				broadcastToTeam1(new ExDuelUpdateUserInfo(partyPlayer));
+			}
+			
+			// Send duel Start packets.
 			ExDuelReady ready = new ExDuelReady(1);
 			ExDuelStart start = new ExDuelStart(1);
@@ -382,11 +357,11 @@
 		else
 		{
-			// set isInDuel() state
-			_playerA.setIsInDuel(_duelId);
+			// Set states.
+			_playerA.setInDuel(_duelId);
 			_playerA.setTeam(1);
-			_playerB.setIsInDuel(_duelId);
+			_playerB.setInDuel(_duelId);
 			_playerB.setTeam(2);
 			
-			// Send duel Start packets
+			// Send duel Start packets.
 			ExDuelReady ready = new ExDuelReady(0);
 			ExDuelStart start = new ExDuelStart(0);
@@ -401,14 +376,12 @@
 			
 			_playerA.broadcastUserInfo();
+			// TODO Servitors getTeam update
 			_playerB.broadcastUserInfo();
-		}
-		
-		// play sound
-		PlaySound ps = new PlaySound(1, "B04_S01", 0, 0, 0, 0, 0);
-		broadcastToTeam1(ps);
-		broadcastToTeam2(ps);
-		
-		// start duelling task
-		ThreadPoolManager.getInstance().scheduleGeneral(new ScheduleDuelTask(this), 1000);
+			// TODO Servitors getTeam update
+		}
+		
+		// Play sound.
+		broadcastToTeam1(B04_S01);
+		broadcastToTeam2(B04_S01);
 	}
 	
@@ -416,13 +389,13 @@
 	 * Save the current player condition: hp, mp, cp, location
 	 */
-	public void savePlayerConditions()
+	private void savePlayerConditions()
 	{
 		if (_partyDuel)
 		{
-			for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-				_playerConditions.add(new PlayerCondition(temp, _partyDuel));
-			
-			for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-				_playerConditions.add(new PlayerCondition(temp, _partyDuel));
+			for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+				_playerConditions.add(new PlayerCondition(partyPlayer, _partyDuel));
+			
+			for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+				_playerConditions.add(new PlayerCondition(partyPlayer, _partyDuel));
 		}
 		else
@@ -434,47 +407,50 @@
 	
 	/**
-	 * Restore player conditions
-	 * @param abnormalDuelEnd was the duel canceled?
-	 */
-	public void restorePlayerConditions(boolean abnormalDuelEnd)
-	{
-		// update isInDuel() state for all players
+	 * Restore player conditions.
+	 * @param abnormalEnd : true if the duel was canceled.
+	 */
+	private void restorePlayerConditions(boolean abnormalEnd)
+	{
 		if (_partyDuel)
 		{
-			for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-			{
-				temp.setIsInDuel(0);
-				temp.setTeam(0);
-				temp.broadcastUserInfo();
-			}
-			for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-			{
-				temp.setIsInDuel(0);
-				temp.setTeam(0);
-				temp.broadcastUserInfo();
+			for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+			{
+				partyPlayer.setInDuel(0);
+				partyPlayer.setTeam(0);
+				partyPlayer.broadcastUserInfo();
+				// TODO Servitors getTeam update
+			}
+			
+			for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+			{
+				partyPlayer.setInDuel(0);
+				partyPlayer.setTeam(0);
+				partyPlayer.broadcastUserInfo();
+				// TODO Servitors getTeam update
 			}
 		}
 		else
 		{
-			_playerA.setIsInDuel(0);
+			_playerA.setInDuel(0);
 			_playerA.setTeam(0);
 			_playerA.broadcastUserInfo();
-			_playerB.setIsInDuel(0);
+			// TODO Servitors getTeam update
+			
+			_playerB.setInDuel(0);
 			_playerB.setTeam(0);
 			_playerB.broadcastUserInfo();
-		}
-		
-		// if it is an abnormal DuelEnd do not restore hp, mp, cp
-		if (abnormalDuelEnd)
-			return;
-		
-		// restore player conditions
-		for (PlayerCondition cond : _playerConditions)
-			cond.restoreCondition();
-	}
-	
-	/**
-	 * Get the duel id
-	 * @return id
+			// TODO Servitors getTeam update
+		}
+		
+		// Restore player conditions, but only for party duel (no matter the end) && 1vs1 which ends normally.
+		if ((!_partyDuel && !abnormalEnd) || _partyDuel)
+		{
+			for (PlayerCondition cond : _playerConditions)
+				cond.restoreCondition(abnormalEnd);
+		}
+	}
+	
+	/**
+	 * @return the duel id.
 	 */
 	public int getId()
@@ -484,6 +460,5 @@
 	
 	/**
-	 * Returns the remaining time
-	 * @return remaining time
+	 * @return the remaining time.
 	 */
 	public int getRemainingTime()
@@ -493,6 +468,5 @@
 	
 	/**
-	 * Get the player that requestet the duel
-	 * @return duel requester
+	 * @return the player that requested the duel.
 	 */
 	public L2PcInstance getPlayerA()
@@ -502,6 +476,5 @@
 	
 	/**
-	 * Get the player that was challenged
-	 * @return challenged player
+	 * @return the player that was challenged.
 	 */
 	public L2PcInstance getPlayerB()
@@ -511,6 +484,5 @@
 	
 	/**
-	 * Returns whether this is a party duel or not
-	 * @return is party duel
+	 * @return true if the duel was a party duel, false otherwise.
 	 */
 	public boolean isPartyDuel()
@@ -519,21 +491,11 @@
 	}
 	
-	public void setFinished(boolean mode)
-	{
-		_finished = mode;
-	}
-	
-	public boolean getFinished()
-	{
-		return _finished;
-	}
-	
-	/**
-	 * teleport all players to the given coordinates
+	/**
+	 * Teleport all players to the given coordinates. Used by party duel only.
 	 * @param x
 	 * @param y
 	 * @param z
 	 */
-	public void teleportPlayers(int x, int y, int z)
+	protected void teleportPlayers(int x, int y, int z)
 	{
 		// TODO: adjust the values if needed... or implement something better (especially using more then 1 arena)
@@ -543,14 +505,14 @@
 		int offset = 0;
 		
-		for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-		{
-			temp.teleToLocation(x + offset - 180, y - 150, z, 0);
+		for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+		{
+			partyPlayer.teleToLocation(x + offset - 180, y - 150, z, 0);
 			offset += 40;
 		}
 		
 		offset = 0;
-		for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-		{
-			temp.teleToLocation(x + offset - 180, y + 150, z, 0);
+		for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+		{
+			partyPlayer.teleToLocation(x + offset - 180, y + 150, z, 0);
 			offset += 40;
 		}
@@ -558,16 +520,13 @@
 	
 	/**
-	 * Broadcast a packet to the challenger team
-	 * @param packet The packet to send.
+	 * Broadcast a packet to the challenger team.
+	 * @param packet : The packet to send.
 	 */
 	public void broadcastToTeam1(L2GameServerPacket packet)
 	{
-		if (_playerA == null)
-			return;
-		
 		if (_partyDuel && _playerA.getParty() != null)
 		{
-			for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-				temp.sendPacket(packet);
+			for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+				partyPlayer.sendPacket(packet);
 		}
 		else
@@ -576,16 +535,13 @@
 	
 	/**
-	 * Broadcast a packet to the challenged team
-	 * @param packet The packet to send.
+	 * Broadcast a packet to the challenged team.
+	 * @param packet : The packet to send.
 	 */
 	public void broadcastToTeam2(L2GameServerPacket packet)
 	{
-		if (_playerB == null)
-			return;
-		
 		if (_partyDuel && _playerB.getParty() != null)
 		{
-			for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-				temp.sendPacket(packet);
+			for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+				partyPlayer.sendPacket(packet);
 		}
 		else
@@ -594,242 +550,225 @@
 	
 	/**
-	 * Get the duel looser
-	 * @return looser
-	 */
-	public L2PcInstance getLooser()
-	{
-		if (!getFinished() || _playerA == null || _playerB == null)
-			return null;
-		if (_playerA.getDuelState() == DUELSTATE_WINNER)
-			return _playerB;
-		else if (_playerA.getDuelState() == DUELSTATE_WINNER)
-			return _playerA;
-		
-		return null;
-	}
-	
-	/**
-	 * Playback the bow animation for all loosers
-	 */
-	public void playKneelAnimation()
-	{
-		L2PcInstance looser = getLooser();
-		if (looser == null)
-			return;
-		
-		if (_partyDuel && looser.getParty() != null)
-		{
-			for (L2PcInstance temp : looser.getParty().getPartyMembers())
-				temp.broadcastPacket(new SocialAction(temp, 7));
-		}
-		else
-			looser.broadcastPacket(new SocialAction(looser, 7));
-	}
-	
-	/**
-	 * Do the countdown and send message to players if necessary
-	 * @return current count
-	 */
-	public int countdown()
-	{
-		_countdown--;
-		
-		if (_countdown > 3)
-			return _countdown;
-		
-		// Broadcast countdown to duelists
+	 * Playback the bow animation for loosers, victory pose for winners.<br>
+	 * The method works even if other side is null or offline.
+	 */
+	protected void playAnimations()
+	{
+		if (_playerA.isOnline())
+		{
+			if (_playerA.getDuelState() == DuelState.WINNER)
+			{
+				if (_partyDuel && _playerA.getParty() != null)
+				{
+					for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+						partyPlayer.broadcastPacket(new SocialAction(partyPlayer, 3));
+				}
+				else
+					_playerA.broadcastPacket(new SocialAction(_playerA, 3));
+			}
+			else if (_playerA.getDuelState() == DuelState.DEAD)
+			{
+				if (_partyDuel && _playerA.getParty() != null)
+				{
+					for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+						partyPlayer.broadcastPacket(new SocialAction(partyPlayer, 7));
+				}
+				else
+					_playerA.broadcastPacket(new SocialAction(_playerA, 7));
+			}
+		}
+		
+		if (_playerB.isOnline())
+		{
+			if (_playerB.getDuelState() == DuelState.WINNER)
+			{
+				if (_partyDuel && _playerB.getParty() != null)
+				{
+					for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+						partyPlayer.broadcastPacket(new SocialAction(partyPlayer, 3));
+				}
+				else
+					_playerB.broadcastPacket(new SocialAction(_playerB, 3));
+			}
+			else if (_playerB.getDuelState() == DuelState.DEAD)
+			{
+				if (_partyDuel && _playerB.getParty() != null)
+				{
+					for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+						partyPlayer.broadcastPacket(new SocialAction(partyPlayer, 7));
+				}
+				else
+					_playerB.broadcastPacket(new SocialAction(_playerB, 7));
+			}
+		}
+	}
+	
+	/**
+	 * This method ends a duel, sending messages to each team, end duel packet, cleaning player conditions and then removing duel from manager.
+	 * @param result : The duel result.
+	 */
+	protected void endDuel(DuelResult result)
+	{
 		SystemMessage sm = null;
-		if (_countdown > 0)
-		{
-			sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_WILL_BEGIN_IN_S1_SECONDS);
-			sm.addNumber(_countdown);
-		}
-		else
-			sm = SystemMessage.getSystemMessage(SystemMessageId.LET_THE_DUEL_BEGIN);
+		switch (result)
+		{
+			case TEAM_2_SURRENDER:
+				sm = SystemMessage.getSystemMessage((_partyDuel) ? SystemMessageId.SINCE_S1_PARTY_WITHDREW_FROM_THE_DUEL_S2_PARTY_HAS_WON : SystemMessageId.SINCE_S1_WITHDREW_FROM_THE_DUEL_S2_HAS_WON).addString(_playerB.getName()).addString(_playerA.getName());
+				broadcastToTeam1(sm);
+				broadcastToTeam2(sm);
+			case TEAM_1_WIN:
+				sm = SystemMessage.getSystemMessage((_partyDuel) ? SystemMessageId.S1_PARTY_HAS_WON_THE_DUEL : SystemMessageId.S1_HAS_WON_THE_DUEL).addString(_playerA.getName());
+				break;
+			
+			case TEAM_1_SURRENDER:
+				sm = SystemMessage.getSystemMessage((_partyDuel) ? SystemMessageId.SINCE_S1_PARTY_WITHDREW_FROM_THE_DUEL_S2_PARTY_HAS_WON : SystemMessageId.SINCE_S1_WITHDREW_FROM_THE_DUEL_S2_HAS_WON).addString(_playerA.getName()).addString(_playerB.getName());
+				broadcastToTeam1(sm);
+				broadcastToTeam2(sm);
+			case TEAM_2_WIN:
+				sm = SystemMessage.getSystemMessage((_partyDuel) ? SystemMessageId.S1_PARTY_HAS_WON_THE_DUEL : SystemMessageId.S1_HAS_WON_THE_DUEL).addString(_playerB.getName());
+				break;
+			
+			case CANCELED:
+				sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_HAS_ENDED_IN_A_TIE);
+				break;
+			
+			case TIMEOUT:
+				sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_HAS_ENDED_IN_A_TIE);
+				break;
+		}
 		
 		broadcastToTeam1(sm);
 		broadcastToTeam2(sm);
 		
-		return _countdown;
-	}
-	
-	/**
-	 * The duel has reached a state in which it can no longer continue
-	 * @param result The duel result state.
-	 */
-	public void endDuel(DuelResultEnum result)
-	{
-		if (_playerA == null || _playerB == null)
-		{
-			// clean up
-			_playerConditions.clear();
-			_playerConditions = null;
-			DuelManager.getInstance().removeDuel(this);
-			return;
-		}
-		
-		// inform players of the result
-		SystemMessage sm = null;
-		switch (result)
-		{
-			case Team1Win:
-				restorePlayerConditions(false);
-				// send SystemMessage
-				if (_partyDuel)
-					sm = SystemMessage.getSystemMessage(SystemMessageId.S1_PARTY_HAS_WON_THE_DUEL);
-				else
-					sm = SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_WON_THE_DUEL);
-				sm.addString(_playerA.getName());
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-			case Team2Win:
-				restorePlayerConditions(false);
-				// send SystemMessage
-				if (_partyDuel)
-					sm = SystemMessage.getSystemMessage(SystemMessageId.S1_PARTY_HAS_WON_THE_DUEL);
-				else
-					sm = SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_WON_THE_DUEL);
-				sm.addString(_playerB.getName());
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-			case Team1Surrender:
-				restorePlayerConditions(false);
-				// send SystemMessage
-				if (_partyDuel)
-					sm = SystemMessage.getSystemMessage(SystemMessageId.SINCE_S1_PARTY_WITHDREW_FROM_THE_DUEL_S2_PARTY_HAS_WON);
-				else
-					sm = SystemMessage.getSystemMessage(SystemMessageId.SINCE_S1_WITHDREW_FROM_THE_DUEL_S2_HAS_WON);
-				sm.addString(_playerA.getName());
-				sm.addString(_playerB.getName());
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-			case Team2Surrender:
-				restorePlayerConditions(false);
-				// send SystemMessage
-				if (_partyDuel)
-					sm = SystemMessage.getSystemMessage(SystemMessageId.SINCE_S1_PARTY_WITHDREW_FROM_THE_DUEL_S2_PARTY_HAS_WON);
-				else
-					sm = SystemMessage.getSystemMessage(SystemMessageId.SINCE_S1_WITHDREW_FROM_THE_DUEL_S2_HAS_WON);
-				sm.addString(_playerB.getName());
-				sm.addString(_playerA.getName());
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-			case Canceled:
-				stopFighting();
-				// dont restore hp, mp, cp
-				restorePlayerConditions(true);
-				// send SystemMessage
-				sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_HAS_ENDED_IN_A_TIE);
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-			case Timeout:
-				stopFighting();
-				// hp,mp,cp seem to be restored in a timeout too...
-				restorePlayerConditions(false);
-				// send SystemMessage
-				sm = SystemMessage.getSystemMessage(SystemMessageId.THE_DUEL_HAS_ENDED_IN_A_TIE);
-				
-				broadcastToTeam1(sm);
-				broadcastToTeam2(sm);
-				break;
-		}
-		
-		// Send end duel packet
-		ExDuelEnd duelEnd = null;
-		if (_partyDuel)
-			duelEnd = new ExDuelEnd(1);
-		else
-			duelEnd = new ExDuelEnd(0);
+		restorePlayerConditions(result == DuelResult.CANCELED);
+		
+		// Send end duel packet.
+		ExDuelEnd duelEnd = new ExDuelEnd((_partyDuel) ? 1 : 0);
 		
 		broadcastToTeam1(duelEnd);
 		broadcastToTeam2(duelEnd);
 		
-		// clean up
+		// Cleanup.
 		_playerConditions.clear();
-		_playerConditions = null;
 		DuelManager.getInstance().removeDuel(this);
 	}
 	
 	/**
-	 * Did a situation occur in which the duel has to be ended?
-	 * @return DuelResultEnum duel status
-	 */
-	public DuelResultEnum checkEndDuelCondition()
-	{
-		// one of the players might leave during duel
-		if (_playerA == null || _playerB == null)
-			return DuelResultEnum.Canceled;
-		
-		// got a duel surrender request?
+	 * This method checks all possible scenari which can disturb a duel, and return the appropriate status.
+	 * @return DuelResult : The duel status.
+	 */
+	protected DuelResult checkEndDuelCondition()
+	{
+		// Both players are offline.
+		if (!_playerA.isOnline() && !_playerB.isOnline())
+			return DuelResult.CANCELED;
+		
+		// Player A is offline.
+		if (!_playerA.isOnline())
+		{
+			onPlayerDefeat(_playerA);
+			return DuelResult.TEAM_1_SURRENDER;
+		}
+		
+		// Player B is offline.
+		if (!_playerB.isOnline())
+		{
+			onPlayerDefeat(_playerB);
+			return DuelResult.TEAM_2_SURRENDER;
+		}
+		
+		// Duel surrender request.
 		if (_surrenderRequest != 0)
-		{
-			if (_surrenderRequest == 1)
-				return DuelResultEnum.Team1Surrender;
-			
-			return DuelResultEnum.Team2Surrender;
-		}
-		// duel timed out
-		else if (getRemainingTime() <= 0)
-			return DuelResultEnum.Timeout;
-		// Has a player been declared winner yet?
-		else if (_playerA.getDuelState() == DUELSTATE_WINNER)
-		{
-			// If there is a Winner already there should be no more fighting going on
-			stopFighting();
-			return DuelResultEnum.Team1Win;
-		}
-		else if (_playerB.getDuelState() == DUELSTATE_WINNER)
-		{
-			// If there is a Winner already there should be no more fighting going on
-			stopFighting();
-			return DuelResultEnum.Team2Win;
-		}
-		
-		// More end duel conditions for 1on1 duels
-		else if (!_partyDuel)
+			return (_surrenderRequest == 1) ? DuelResult.TEAM_1_SURRENDER : DuelResult.TEAM_2_SURRENDER;
+		
+		// Duel timed out.
+		if (getRemainingTime() <= 0)
+			return DuelResult.TIMEOUT;
+		
+		// One of the players is declared winner.
+		if (_playerA.getDuelState() == DuelState.WINNER)
+			return DuelResult.TEAM_1_WIN;
+		
+		if (_playerB.getDuelState() == DuelState.WINNER)
+			return DuelResult.TEAM_2_WIN;
+		
+		if (!_partyDuel)
 		{
 			// Duel was interrupted e.g.: player was attacked by mobs / other players
-			if (_playerA.getDuelState() == DUELSTATE_INTERRUPTED || _playerB.getDuelState() == DUELSTATE_INTERRUPTED)
-				return DuelResultEnum.Canceled;
-			
-			// Are the players too far apart?
-			if (!_playerA.isInsideRadius(_playerB, 1600, false, false))
-				return DuelResultEnum.Canceled;
-			
-			// Did one of the players engage in PvP combat?
-			if (isDuelistInPvp(true))
-				return DuelResultEnum.Canceled;
-			
-			// is one of the players in a Siege, Peace or PvP zone?
+			if (_playerA.getDuelState() == DuelState.INTERRUPTED || _playerB.getDuelState() == DuelState.INTERRUPTED)
+				return DuelResult.CANCELED;
+			
+			// Players are too far apart.
+			if (!_playerA.isInsideRadius(_playerB, 2000, false, false))
+				return DuelResult.CANCELED;
+			
+			// One of the players is engaged in PvP.
+			if (_playerA.getPvpFlag() != 0 || _playerB.getPvpFlag() != 0)
+				return DuelResult.CANCELED;
+			
+			// One of the players is in a Siege, Peace or PvP zone.
 			if (_playerA.isInsideZone(ZoneId.PEACE) || _playerB.isInsideZone(ZoneId.PEACE) || _playerA.isInsideZone(ZoneId.SIEGE) || _playerB.isInsideZone(ZoneId.SIEGE) || _playerA.isInsideZone(ZoneId.PVP) || _playerB.isInsideZone(ZoneId.PVP))
-				return DuelResultEnum.Canceled;
-		}
-		
-		return DuelResultEnum.Continue;
-	}
-	
-	/**
-	 * Register a surrender request
-	 * @param player The player instance who surrender.
+				return DuelResult.CANCELED;
+		}
+		else
+		{
+			if (_playerA.getParty() != null)
+			{
+				for (L2PcInstance partyMember : _playerA.getParty().getPartyMembers())
+				{
+					// Duel was interrupted e.g.: player was attacked by mobs / other players
+					if (partyMember.getDuelState() == DuelState.INTERRUPTED)
+						return DuelResult.CANCELED;
+					
+					// Players are too far apart.
+					if (!partyMember.isInsideRadius(_playerB, 2000, false, false))
+						return DuelResult.CANCELED;
+					
+					// One of the players is engaged in PvP.
+					if (partyMember.getPvpFlag() != 0)
+						return DuelResult.CANCELED;
+					
+					// One of the players is in a Siege, Peace or PvP zone.
+					if (partyMember.isInsideZone(ZoneId.PEACE) || partyMember.isInsideZone(ZoneId.PEACE) || partyMember.isInsideZone(ZoneId.SIEGE))
+						return DuelResult.CANCELED;
+				}
+			}
+			
+			if (_playerB.getParty() != null)
+			{
+				for (L2PcInstance partyMember : _playerB.getParty().getPartyMembers())
+				{
+					// Duel was interrupted e.g.: player was attacked by mobs / other players
+					if (partyMember.getDuelState() == DuelState.INTERRUPTED)
+						return DuelResult.CANCELED;
+					
+					// Players are too far apart.
+					if (!partyMember.isInsideRadius(_playerA, 2000, false, false))
+						return DuelResult.CANCELED;
+					
+					// One of the players is engaged in PvP.
+					if (partyMember.getPvpFlag() != 0)
+						return DuelResult.CANCELED;
+					
+					// One of the players is in a Siege, Peace or PvP zone.
+					if (partyMember.isInsideZone(ZoneId.PEACE) || partyMember.isInsideZone(ZoneId.PEACE) || partyMember.isInsideZone(ZoneId.SIEGE))
+						return DuelResult.CANCELED;
+				}
+			}
+		}
+		
+		return DuelResult.CONTINUE;
+	}
+	
+	/**
+	 * Register a surrender request. It updates DuelState of players.
+	 * @param player : The player who surrenders.
 	 */
 	public void doSurrender(L2PcInstance player)
 	{
-		// already recived a surrender request
+		// A surrender request is already under process, return.
 		if (_surrenderRequest != 0)
 			return;
 		
-		// stop the fight
-		stopFighting();
-		
 		// TODO: Can every party member cancel a party duel? or only the party leaders?
 		if (_partyDuel)
@@ -838,18 +777,20 @@
 			{
 				_surrenderRequest = 1;
-				for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-					temp.setDuelState(DUELSTATE_DEAD);
-				
-				for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-					temp.setDuelState(DUELSTATE_WINNER);
+				
+				for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+					partyPlayer.setDuelState(DuelState.DEAD);
+				
+				for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+					partyPlayer.setDuelState(DuelState.WINNER);
 			}
 			else if (_playerB.getParty().getPartyMembers().contains(player))
 			{
 				_surrenderRequest = 2;
-				for (L2PcInstance temp : _playerB.getParty().getPartyMembers())
-					temp.setDuelState(DUELSTATE_DEAD);
-				
-				for (L2PcInstance temp : _playerA.getParty().getPartyMembers())
-					temp.setDuelState(DUELSTATE_WINNER);
+				
+				for (L2PcInstance partyPlayer : _playerB.getParty().getPartyMembers())
+					partyPlayer.setDuelState(DuelState.DEAD);
+				
+				for (L2PcInstance partyPlayer : _playerA.getParty().getPartyMembers())
+					partyPlayer.setDuelState(DuelState.WINNER);
 			}
 		}
@@ -859,38 +800,40 @@
 			{
 				_surrenderRequest = 1;
-				_playerA.setDuelState(DUELSTATE_DEAD);
-				_playerB.setDuelState(DUELSTATE_WINNER);
+				
+				_playerA.setDuelState(DuelState.DEAD);
+				_playerB.setDuelState(DuelState.WINNER);
 			}
 			else if (player == _playerB)
 			{
 				_surrenderRequest = 2;
-				_playerB.setDuelState(DUELSTATE_DEAD);
-				_playerA.setDuelState(DUELSTATE_WINNER);
-			}
-		}
-	}
-	
-	/**
-	 * This function is called whenever a player was defeated in a duel
-	 * @param player The defeated player instance.
+				
+				_playerB.setDuelState(DuelState.DEAD);
+				_playerA.setDuelState(DuelState.WINNER);
+			}
+		}
+	}
+	
+	/**
+	 * This method is called whenever a player was defeated in a duel. It updates DuelState of players.
+	 * @param player : The defeated player.
 	 */
 	public void onPlayerDefeat(L2PcInstance player)
 	{
-		// Set player as defeated
-		player.setDuelState(DUELSTATE_DEAD);
+		// Set player as defeated.
+		player.setDuelState(DuelState.DEAD);
 		
 		if (_partyDuel)
 		{
-			boolean teamdefeated = true;
-			for (L2PcInstance temp : player.getParty().getPartyMembers())
-			{
-				if (temp.getDuelState() == DUELSTATE_DUELLING)
+			boolean teamDefeated = true;
+			for (L2PcInstance partyPlayer : player.getParty().getPartyMembers())
+			{
+				if (partyPlayer.getDuelState() == DuelState.DUELLING)
 				{
-					teamdefeated = false;
+					teamDefeated = false;
 					break;
 				}
 			}
 			
-			if (teamdefeated)
+			if (teamDefeated)
 			{
 				L2PcInstance winner = _playerA;
@@ -898,32 +841,32 @@
 					winner = _playerB;
 				
-				for (L2PcInstance temp : winner.getParty().getPartyMembers())
-					temp.setDuelState(DUELSTATE_WINNER);
+				for (L2PcInstance partyPlayer : winner.getParty().getPartyMembers())
+					partyPlayer.setDuelState(DuelState.WINNER);
 			}
 		}
 		else
 		{
-			if (player != _playerA && player != _playerB)
-				_log.warning("Error in onPlayerDefeat(): player is not part of this 1vs1 duel");
-			
 			if (_playerA == player)
-				_playerB.setDuelState(DUELSTATE_WINNER);
+				_playerB.setDuelState(DuelState.WINNER);
 			else
-				_playerA.setDuelState(DUELSTATE_WINNER);
-		}
-	}
-	
-	/**
-	 * This function is called whenever a player leaves a party
-	 * @param player The player instance who left.
+				_playerA.setDuelState(DuelState.WINNER);
+		}
+	}
+	
+	/**
+	 * This method is called when a player left a party.
+	 * <ul>
+	 * <li>The player was a party leader : the duel is canceled.</li>
+	 * <li>The player was a regular member : the duel continues, but all infos regarding this player are dropped from duel.</li>
+	 * </ul>
+	 * @param player : The player who left.
 	 */
 	public void onRemoveFromParty(L2PcInstance player)
 	{
-		// if it isnt a party duel ignore this
+		// The duel isn't a party duel, ignore it.
 		if (!_partyDuel)
 			return;
 		
-		// this player is leaving his party during party duel
-		// if hes either playerA or playerB cancel the duel and port the players back
+		// The player is leaving his party during party duel ; if he's playerA or playerB cancel the duel and port the players back.
 		if (player == _playerA || player == _playerB)
 		{
@@ -931,12 +874,10 @@
 			{
 				cond.teleportBack();
-				cond.getPlayer().setIsInDuel(0);
-			}
-			
-			_playerA = null;
-			_playerB = null;
-		}
+				cond.getPlayer().setInDuel(0);
+			}
+			endDuel(DuelResult.CANCELED);
+		}
+		// Otherwise, teleport the player back & delete his PlayerCondition record. The duel continues.
 		else
-		// teleport the player back & delete his PlayerCondition record
 		{
 			for (PlayerCondition cond : _playerConditions)
@@ -949,9 +890,14 @@
 				}
 			}
-			player.setIsInDuel(0);
-		}
-	}
-	
-	public void onBuff(L2PcInstance player, L2Effect debuff)
+			player.setInDuel(0);
+		}
+	}
+	
+	/**
+	 * This method is called to register an effect.
+	 * @param player : The player condition to affect.
+	 * @param effect : The effect to register.
+	 */
+	public void onBuff(L2PcInstance player, L2Effect effect)
 	{
 		for (PlayerCondition cond : _playerConditions)
@@ -959,5 +905,5 @@
 			if (cond.getPlayer() == player)
 			{
-				cond.registerDebuff(debuff);
+				cond.registerDebuff(effect);
 				return;
 			}
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/handler/usercommandhandlers/ChannelLeave.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/handler/usercommandhandlers/ChannelLeave.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/handler/usercommandhandlers/ChannelLeave.java	(revision 344)
@@ -22,7 +22,4 @@
 import net.sf.l2j.gameserver.network.serverpackets.SystemMessage;
 
-/**
- * @author Chris
- */
 public class ChannelLeave implements IUserCommandHandler
 {
@@ -35,10 +32,10 @@
 	public boolean useUserCommand(int id, L2PcInstance activeChar)
 	{
-		if (activeChar.isInParty())
+		final L2Party party = activeChar.getParty();
+		if (party != null)
 		{
-			if (activeChar.getParty().isLeader(activeChar) && activeChar.getParty().isInCommandChannel())
+			if (party.isLeader(activeChar) && party.isInCommandChannel())
 			{
-				L2CommandChannel channel = activeChar.getParty().getCommandChannel();
-				L2Party party = activeChar.getParty();
+				final L2CommandChannel channel = party.getCommandChannel();
 				channel.removeParty(party);
 				
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelStart.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelStart.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelStart.java	(revision 344)
@@ -15,5 +15,6 @@
 package net.sf.l2j.gameserver.network.clientpackets;
 
-import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.model.L2CommandChannel;
+import net.sf.l2j.gameserver.model.L2Party;
 import net.sf.l2j.gameserver.model.L2World;
 import net.sf.l2j.gameserver.model.actor.instance.L2PcInstance;
@@ -22,8 +23,4 @@
 import net.sf.l2j.gameserver.network.serverpackets.SystemMessage;
 
-/**
- * Format:(ch) Sd
- * @author -Wooden-
- */
 public final class RequestDuelStart extends L2GameClientPacket
 {
@@ -52,5 +49,5 @@
 		}
 		
-		// Check if duel is possible
+		// Check if duel is possible.
 		if (!activeChar.canDuel())
 		{
@@ -65,6 +62,6 @@
 		}
 		
-		// Players may not be too far apart
-		if (!activeChar.isInsideRadius(targetChar, 250, false, false))
+		// Players musn't be too far.
+		if (!activeChar.isInsideRadius(targetChar, 2000, false, false))
 		{
 			activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_CANNOT_RECEIVE_A_DUEL_CHALLENGE_BECAUSE_S1_IS_TOO_FAR_AWAY).addPcName(targetChar));
@@ -72,16 +69,18 @@
 		}
 		
-		// Duel is a party duel
+		// Duel is a party duel.
 		if (_partyDuel == 1)
 		{
-			// Player must be in a party & the party leader
-			if (!activeChar.isInParty() || !(activeChar.getParty().isLeader(activeChar)))
+			// Player must be a party leader, the target can't be of the same party.
+			final L2Party activeCharParty = activeChar.getParty();
+			if (activeCharParty == null || !activeCharParty.isLeader(activeChar) || activeCharParty.getPartyMembers().contains(targetChar))
 			{
-				activeChar.sendMessage("You have to be the leader of a party in order to request a party duel.");
+				activeChar.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
 				return;
 			}
 			
-			// Target must be in a party
-			if (!targetChar.isInParty())
+			// Target must be in a party.
+			final L2Party targetCharParty = targetChar.getParty();
+			if (targetCharParty == null)
 			{
 				activeChar.sendPacket(SystemMessageId.SINCE_THE_PERSON_YOU_CHALLENGED_IS_NOT_CURRENTLY_IN_A_PARTY_THEY_CANNOT_DUEL_AGAINST_YOUR_PARTY);
@@ -89,15 +88,8 @@
 			}
 			
-			// Target may not be of the same party
-			if (activeChar.getParty().getPartyMembers().contains(targetChar))
+			// Check if every player is ready for a duel.
+			for (L2PcInstance partyMember : activeCharParty.getPartyMembers())
 			{
-				activeChar.sendMessage("This player is a member of your own party.");
-				return;
-			}
-			
-			// Check if every player is ready for a duel
-			for (L2PcInstance temp : activeChar.getParty().getPartyMembers())
-			{
-				if (!temp.canDuel())
+				if (partyMember != activeChar && !partyMember.canDuel())
 				{
 					activeChar.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
@@ -106,7 +98,7 @@
 			}
 			
-			for (L2PcInstance temp : targetChar.getParty().getPartyMembers())
+			for (L2PcInstance partyMember : targetCharParty.getPartyMembers())
 			{
-				if (!temp.canDuel())
+				if (partyMember != targetChar && !partyMember.canDuel())
 				{
 					activeChar.sendPacket(SystemMessageId.THE_OPPOSING_PARTY_IS_CURRENTLY_UNABLE_TO_ACCEPT_A_CHALLENGE_TO_A_DUEL);
@@ -115,14 +107,22 @@
 			}
 			
-			final L2PcInstance partyLeader = targetChar.getParty().getLeader();
+			final L2PcInstance partyLeader = targetCharParty.getLeader();
 			
-			// Send request to targetChar's party leader
+			// Send request to targetChar's party leader.
 			if (!partyLeader.isProcessingRequest())
 			{
+				// Drop command channels, for both requestor && player parties.
+				final L2CommandChannel activeCharChannel = activeCharParty.getCommandChannel();
+				if (activeCharChannel != null)
+					activeCharChannel.removeParty(activeCharParty);
+				
+				final L2CommandChannel targetCharChannel = targetCharParty.getCommandChannel();
+				if (targetCharChannel != null)
+					targetCharChannel.removeParty(targetCharParty);
+				
+				// TODO partymatching
+				
 				activeChar.onTransactionRequest(partyLeader);
 				partyLeader.sendPacket(new ExDuelAskStart(activeChar.getName(), _partyDuel));
-				
-				if (Config.DEBUG)
-					_log.fine(activeChar.getName() + " requested a duel with " + partyLeader.getName());
 				
 				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_PARTY_HAS_BEEN_CHALLENGED_TO_A_DUEL).addPcName(partyLeader));
@@ -132,14 +132,13 @@
 				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_IS_BUSY_TRY_LATER).addPcName(partyLeader));
 		}
+		// 1vs1 duel.
 		else
-		// 1vs1 duel
 		{
 			if (!targetChar.isProcessingRequest())
 			{
+				// TODO partymatching
+				
 				activeChar.onTransactionRequest(targetChar);
 				targetChar.sendPacket(new ExDuelAskStart(activeChar.getName(), _partyDuel));
-				
-				if (Config.DEBUG)
-					_log.fine(activeChar.getName() + " requested a duel with " + targetChar.getName());
 				
 				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_BEEN_CHALLENGED_TO_A_DUEL).addPcName(targetChar));
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelAnswerStart.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelAnswerStart.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestDuelAnswerStart.java	(revision 344)
@@ -16,12 +16,10 @@
 
 import net.sf.l2j.gameserver.instancemanager.DuelManager;
+import net.sf.l2j.gameserver.model.L2CommandChannel;
+import net.sf.l2j.gameserver.model.L2Party;
 import net.sf.l2j.gameserver.model.actor.instance.L2PcInstance;
 import net.sf.l2j.gameserver.network.SystemMessageId;
 import net.sf.l2j.gameserver.network.serverpackets.SystemMessage;
 
-/**
- * Format:(ch) ddd
- * @author -Wooden-
- */
 public final class RequestDuelAnswerStart extends L2GameClientPacket
 {
@@ -42,9 +40,9 @@
 	protected void runImpl()
 	{
-		final L2PcInstance player = getClient().getActiveChar();
-		if (player == null)
+		final L2PcInstance activeChar = getClient().getActiveChar();
+		if (activeChar == null)
 			return;
 		
-		final L2PcInstance requestor = player.getActiveRequester();
+		final L2PcInstance requestor = activeChar.getActiveRequester();
 		if (requestor == null)
 			return;
@@ -52,13 +50,21 @@
 		if (_response == 1)
 		{
-			if (requestor.isInDuel())
+			// Check if duel is possible.
+			if (!requestor.canDuel())
 			{
-				player.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_CANNOT_DUEL_BECAUSE_S1_IS_ALREADY_ENGAGED_IN_A_DUEL).addPcName(requestor));
+				activeChar.sendPacket(requestor.getNoDuelReason());
 				return;
 			}
 			
-			if (player.isInDuel())
+			if (!activeChar.canDuel())
 			{
-				player.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
+				activeChar.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
+				return;
+			}
+			
+			// Players musn't be too far.
+			if (!requestor.isInsideRadius(activeChar, 2000, false, false))
+			{
+				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_CANNOT_RECEIVE_A_DUEL_CHALLENGE_BECAUSE_S1_IS_TOO_FAR_AWAY).addPcName(requestor));
 				return;
 			}
@@ -66,14 +72,62 @@
 			if (_partyDuel == 1)
 			{
-				player.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.YOU_HAVE_ACCEPTED_S1_CHALLENGE_TO_A_PARTY_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(requestor));
-				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_ACCEPTED_YOUR_CHALLENGE_TO_DUEL_AGAINST_THEIR_PARTY_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(player));
+				// Player must be a party leader, the target can't be of the same party.
+				final L2Party requestorParty = requestor.getParty();
+				if (requestorParty == null || !requestorParty.isLeader(requestor) || requestorParty.getPartyMembers().contains(activeChar))
+				{
+					activeChar.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
+					return;
+				}
+				
+				// Target must be in a party.
+				final L2Party activeCharParty = activeChar.getParty();
+				if (activeCharParty == null)
+				{
+					activeChar.sendPacket(SystemMessageId.SINCE_THE_PERSON_YOU_CHALLENGED_IS_NOT_CURRENTLY_IN_A_PARTY_THEY_CANNOT_DUEL_AGAINST_YOUR_PARTY);
+					return;
+				}
+				
+				// Check if every player is ready for a duel.
+				for (L2PcInstance partyMember : requestorParty.getPartyMembers())
+				{
+					if (partyMember != requestor && !partyMember.canDuel())
+					{
+						activeChar.sendPacket(SystemMessageId.YOU_ARE_UNABLE_TO_REQUEST_A_DUEL_AT_THIS_TIME);
+						return;
+					}
+				}
+				
+				for (L2PcInstance partyMember : activeCharParty.getPartyMembers())
+				{
+					if (partyMember != activeChar && !partyMember.canDuel())
+					{
+						activeChar.sendPacket(SystemMessageId.THE_OPPOSING_PARTY_IS_CURRENTLY_UNABLE_TO_ACCEPT_A_CHALLENGE_TO_A_DUEL);
+						return;
+					}
+				}
+				
+				// Drop command channels, for both requestor && player parties.
+				final L2CommandChannel requestorChannel = requestorParty.getCommandChannel();
+				if (requestorChannel != null)
+					requestorChannel.removeParty(requestorParty);
+				
+				final L2CommandChannel activeCharChannel = activeCharParty.getCommandChannel();
+				if (activeCharChannel != null)
+					activeCharChannel.removeParty(activeCharParty);
+				
+				// TODO partymatching
+				
+				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.YOU_HAVE_ACCEPTED_S1_CHALLENGE_TO_A_PARTY_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(requestor));
+				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_ACCEPTED_YOUR_CHALLENGE_TO_DUEL_AGAINST_THEIR_PARTY_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(activeChar));
 			}
 			else
 			{
-				player.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.YOU_HAVE_ACCEPTED_S1_CHALLENGE_TO_A_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(requestor));
-				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_ACCEPTED_YOUR_CHALLENGE_TO_A_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(player));
+				// TODO partymatching
+				
+				activeChar.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.YOU_HAVE_ACCEPTED_S1_CHALLENGE_TO_A_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(requestor));
+				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_ACCEPTED_YOUR_CHALLENGE_TO_A_DUEL_THE_DUEL_WILL_BEGIN_IN_A_FEW_MOMENTS).addPcName(activeChar));
 			}
 			
-			DuelManager.getInstance().addDuel(requestor, player, _partyDuel);
+			DuelManager.getInstance().addDuel(requestor, activeChar, _partyDuel);
 		}
 		else
@@ -82,8 +136,8 @@
 				requestor.sendPacket(SystemMessageId.THE_OPPOSING_PARTY_HAS_DECLINED_YOUR_CHALLENGE_TO_A_DUEL);
 			else
-				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_DECLINED_YOUR_CHALLENGE_TO_A_DUEL).addPcName(player));
+				requestor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.S1_HAS_DECLINED_YOUR_CHALLENGE_TO_A_DUEL).addPcName(activeChar));
 		}
 		
-		player.setActiveRequester(null);
+		activeChar.setActiveRequester(null);
 		requestor.onTransactionResponse();
 	}
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/PartyMatchList.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/PartyMatchList.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/PartyMatchList.java	(revision 344)
@@ -60,25 +60,17 @@
 		}
 		
-		int count = 0;
-		int size = _rooms.size();
-		
 		writeC(0x96);
-		if (size > 0)
-			writeD(1);
-		else
-			writeD(0);
-		
+		writeD((!_rooms.isEmpty()) ? 1 : 0);
 		writeD(_rooms.size());
-		while (size > count)
+		for (PartyMatchRoom room : _rooms)
 		{
-			writeD(_rooms.get(count).getId());
-			writeS(_rooms.get(count).getTitle());
-			writeD(_rooms.get(count).getLocation());
-			writeD(_rooms.get(count).getMinLvl());
-			writeD(_rooms.get(count).getMaxLvl());
-			writeD(_rooms.get(count).getMembers());
-			writeD(_rooms.get(count).getMaxMembers());
-			writeS(_rooms.get(count).getOwner().getName());
-			count++;
+			writeD(room.getId());
+			writeS(room.getTitle());
+			writeD(room.getLocation());
+			writeD(room.getMinLvl());
+			writeD(room.getMaxLvl());
+			writeD(room.getMembers());
+			writeD(room.getMaxMembers());
+			writeS(room.getOwner().getName());
 		}
 	}
Index: /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/ExListPartyMatchingWaitingRoom.java
===================================================================
--- /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/ExListPartyMatchingWaitingRoom.java	(revision 343)
+++ /trunk/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/ExListPartyMatchingWaitingRoom.java	(revision 344)
@@ -83,15 +83,11 @@
 		}
 		
-		int _count = 0;
-		int _size = _members.size();
-		
 		writeD(1);
-		writeD(_size);
-		while (_size > _count)
+		writeD(_members.size());
+		for (L2PcInstance member : _members)
 		{
-			writeS(_members.get(_count).getName());
-			writeD(_members.get(_count).getActiveClass());
-			writeD(_members.get(_count).getLevel());
-			_count++;
+			writeS(member.getName());
+			writeD(member.getActiveClass());
+			writeD(member.getLevel());
 		}
 	}
